# 프로세스 동기화 (Process Synchronization)

## 1. 배경

여러개의 스레드 또는 여러개의 프로세스가 병렬적으로 실행되는 상황에서 동일한 자원에 동시에 접근한다면, 한 프로세스가 공유 data에 접근 중일 때 다른 프로세스가 data를 변경한다면 데이터 일관성을 해칠 수 있다.  
(병렬적 실행이란 time-sharing system에서 정해진 시간동안 프로세스를 동작시키고, 시간이 끝나면 context switching을 하여 여러 작업이 동시에 실행되는 것 처럼 보이도록 하는 것)  
어떤 공유 data에 접근중이면 다른 프로세스의 접근을 제한하는 것을 **프로세스 동기화(Process Synchronization)**라고 한다.

## 2. Critical Section Problem (임계영역 문제)

-   **Critical Section**
    : 병렬적 실행에서, 프로세스 코드 중 공유 data에 접근하는 부분을 Critical Section이라고 한다.

어떤 타이밍에 Critical Section의 코드를 실행중인 프로세스는 단 하나뿐이어야한다.  
만약 두 개 이상의 프로세스가 Critical Section의 코드를 실행중이라면 **Race Condition(경쟁 조건)** 이 발생한다.

Critical Section Problem은 이 방법을 설계한 것이다.

![경쟁조건](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/108acfc8-e856-4d61-ba70-a0ae7b2b607c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210310%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210310T141916Z&X-Amz-Expires=86400&X-Amz-Signature=a9e698ba315abe2e0564bf7829a017fac6dd1c75ae3277e85f178eebd18799e4&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)
`counter++`이 완전히 끝나고 `count--`가 실행된다고 가정하면 `counter = 5`임을 예상할 수 있다.
그러나 병렬실행으로 인해 동시에 두 코드의 critical section이 실행되면 race condition이 발생하고, counter는 5가 아닌 다른값을 가지게 된다.

## 3. 해결책

### 프로세스(Pi) 구조

프로세스 Pi와 Pj가 병렬 실행 중일때라고 가정한다.

```c++
do{
    [entry section] //critical section 시작 전
    {
        [critical section]
    }
    [exit section] //critical section 종료 후
    {
        [remainder section]
    }
} while(true);

```

```c++
do{
    while(trun == j); //i 번째 차례가 아니면 무한루프
    { // turn != j 이면 critical section 진입
        [critical section]
    }
    turn = j; // Pi의 critical section 종료 후 Pj에게 차례를 넘겨준다.
    {
        [remainder section]
    }
} while(true);
```

### 조건

1. Mutual Exclusion(상호 배제)

    어떤 프로세스 Pi 가 Critical Section을 실행중이라면, 다른 프로세스들은 Critical Section을 실행할 수 없다.

2. Progress(진행)

    Critical Section을 실행중인 프로세스는 없고, 진입을 원하는 프로세스들이 있을 때 반드시 바로 프로세스를 선택하여 Critical Section을 실행해야 한다.  
    remainder section을 실행중인 프로세스가 다른 프로세스의 Critical Section 진입을 막을 수 없다.

3. Bounded Waiting(한정된 대기)

    Critical Section에 진입 요청하는 횟수가 유한하다. (언젠가는 반드시 진입할 수 있음)

### 1. Mutex Locks

lock을 얻으면 critical section을 `aquire()`로 보호하고, 실행이 끝나면 `release()`한다.  
lock은 boolean일수도 있고, 두개 이상의 프로세스(또는 스레드)를 병행 실행할 수 있다면 숫자값일 수도 있다.

```c++
do{
    [acquire lock] //critical section 시작 전
    {
        [critical section]
    }
    [release lock] //critical section 종료 후
    {
        [remainder section]
    }
} while(true);

```

```c++
acquire(){
    while(!lock_available); //lock 요청, lock==false이면 무한 대기
    /* busy waiting */
    lock_available = false; //lock을 얻음, 다른 프로세스들은 lock을 얻을 수 없음
}

release(){
    lock_available = true; //lock 반환, 다른 프로세스들이 lock을 얻을 수 있음
}
```

-   단점  
     `aquire()`에서 lock을 요청할 때, 다른 프로세스가 lock을 가지고 있다면, lock이 풀릴 때 까지 무한대기 한다. 이것을 **busy waiting** 또는 **spinlock**이라고 한다.  
    busy waiting은 CPU가 놀고있는 시간이 되기 때문에 CPU 이용률이 감소한다.

---

### 2. Semaphores

소프트웨어상에서 Critical Section 문제를 해결하기 위한 동기화 도구

-   종류

OS 는 Counting/Binary 세마포를 구분한다

    1. 카운팅 세마포

    가용한 개수를 가진 자원 에 대한 접근 제어용으로 사용되며, 세마포는 그 가용한 자원의 개수 로 초기화 된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가 한다.

    2. 이진 세마포

    MUTEX 라고도 부르며, 상호배제의 (Mutual Exclusion)의 머릿글자를 따서 만들어졌다. 이름 그대로 0 과 1 사이의 값만 가능하며, 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해 사용한다.

-   단점

    -   Busy Waiting(바쁜 대기)

    Spin lock이라고 불리는 Semaphore 초기 버전에서 Critical Section 에 진입해야하는 프로세스는 진입 코드를 계속 반복 실행해야 하며, CPU 시간을 낭비했었다. 이를 Busy Waiting이라고 부르며 특수한 상황이 아니면 비효율적이다. 일반적으로는 Semaphore에서 Critical Section에 진입을 시도했지만 실패한 프로세스에 대해 Block시킨 뒤, Critical Section에 자리가 날 때 다시 깨우는 방식을 사용한다. 이 경우 Busy waiting으로 인한 시간낭비 문제가 해결된다.

    -   Deadlock(교착상태)

    세마포가 Ready Queue 를 가지고 있고, 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고, Critical Section 에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되야만 빠져나올 수 있는 상황을 지칭한다.

### 3. 모니터

고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태이다.
공유자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리한다. (세마포어는 직접 키 해제와 공유자원 접근 처리가 필요하다. )
